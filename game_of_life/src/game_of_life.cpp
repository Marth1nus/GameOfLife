// game_of_life.cpp : Defines the entry point for the application.
//

#include "framework.h"
#include "game_of_life.h"

#include "game.hpp"

#include <string>
#include <memory>
#include <format>
#include <utility>
#include <optional>
#include <iostream>

struct resources { 
    HINSTANCE hInstance{};
    std::wstring 
        window_title{},
        window_class{};
};

static HWND hwnd{};
static INT_PTR timer{};
static float target_fps = 30;
static resources win_resources{};
static game_of_life game;

static auto grab_resources(HINSTANCE hInstance) -> resources {
    resources res{.hInstance = hInstance};
    int constexpr buffer_max = 32;
    WCHAR buf[buffer_max]{};

    LoadStringW(hInstance, IDS_APP_TITLE,
        buf, buffer_max);
    res.window_title = buf;

    LoadStringW(hInstance, IDC_GAMEOFLIFE, 
        buf, buffer_max);
    res.window_class = buf;

    return res;
}
static auto register_class(HINSTANCE hInstance, WCHAR const* class_name, WNDPROC window_proc) -> ATOM {
    WNDCLASSEX const wcex{
         .cbSize        /**/ = sizeof(WNDCLASSEX),
         .style         /**/ = CS_HREDRAW | CS_VREDRAW,
         .lpfnWndProc   /**/ = window_proc,
         .cbClsExtra    /**/ = 0,
         .cbWndExtra    /**/ = 0,
         .hInstance     /**/ = hInstance,
         .hIcon         /**/ = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_GAMEOFLIFE)),
         .hCursor       /**/ = LoadCursor(nullptr, IDC_ARROW),
         .hbrBackground /**/ = (HBRUSH)(COLOR_WINDOW + 1),
         .lpszMenuName  /**/ = MAKEINTRESOURCEW(IDC_GAMEOFLIFE),
         .lpszClassName /**/ = class_name,
         .hIconSm       /**/ = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL))
    };
    return RegisterClassExW(&wcex);
}
static auto setup_pixel_format(HDC hdc) -> BOOL {
    PIXELFORMATDESCRIPTOR const pfd{
        .nSize = sizeof(pfd),
        .nVersion = 1,
        .dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        .iPixelType = PFD_TYPE_RGBA,
        .cColorBits = 24,
        .cDepthBits = 16,
    };
    int const pf = ChoosePixelFormat(hdc, &pfd);
    return SetPixelFormat(hdc, pf, &pfd);
}
static auto create_console() -> HWND {
    if (!AllocConsole()) 
        return nullptr;
    FILE* discard_result[1];
    (void)freopen_s(discard_result, "CONIN$", "r", stdin);
    (void)freopen_s(discard_result, "CONOUT$", "w", stdout);
    (void)freopen_s(discard_result, "CONOUT$", "w", stderr);
    puts("Created Console");
    return GetConsoleWindow();
}
static auto reset_game() {
    game = { game.hwnd, game.width, game.height };
    game.build();
    puts("Reset");
}

using hwnd_deleter = decltype([](HWND hwnd) { return DestroyWindow(hwnd); });
using unique_hwnd = std::unique_ptr<std::remove_pointer_t<HWND>, hwnd_deleter>;
static auto make_hwnd(HINSTANCE hInstance, WCHAR const* window_class, WCHAR const* window_title) -> unique_hwnd {
    return unique_hwnd{ CreateWindowExW(0,
        window_class,
        window_title,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        256 * 2,
        256 * 2,
        nullptr,
        nullptr,
        hInstance,
        nullptr
    ) };
}

// Message handler for about box. generated by vs2022
static auto CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) noexcept -> INT_PTR {
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    {
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        }
        break;
    }
    return (INT_PTR)FALSE;
}

void opengl_debug(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char* message, const void* userParam) {
    using namespace std::literals;
    if (severity == GL_DEBUG_SEVERITY_NOTIFICATION) return;
    std::string_view const str_source   /**/ { 
        [source] { switch (source) {
        case GL_DEBUG_SOURCE_API:             /**/ return "API"sv;
        case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   /**/ return "Window System"sv;
        case GL_DEBUG_SOURCE_SHADER_COMPILER: /**/ return "Shader Compiler"sv;
        case GL_DEBUG_SOURCE_THIRD_PARTY:     /**/ return "Third Party"sv;
        case GL_DEBUG_SOURCE_APPLICATION:     /**/ return "Application"sv;
        case GL_DEBUG_SOURCE_OTHER:           /**/ return "Other"sv;
        default: return "???"sv;
        } }() 
    };
    std::string_view const str_type     /**/ { 
        [type] { switch (type) {
        case GL_DEBUG_TYPE_ERROR:               /**/ return "Error"sv;
        case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: /**/ return "Deprecated Behavior"sv;
        case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  /**/ return "Undefined Behavior"sv;
        case GL_DEBUG_TYPE_PORTABILITY:         /**/ return "Portability"sv;
        case GL_DEBUG_TYPE_PERFORMANCE:         /**/ return "Performance"sv;
        case GL_DEBUG_TYPE_MARKER:              /**/ return "Marker"sv;
        case GL_DEBUG_TYPE_PUSH_GROUP:          /**/ return "Push Group"sv;
        case GL_DEBUG_TYPE_POP_GROUP:           /**/ return "Pop Group"sv;
        case GL_DEBUG_TYPE_OTHER:               /**/ return "Other"sv;
        default: return "???"sv;
        } }() 
    };
    std::string_view const str_severity /**/ { 
        [severity] { switch (severity) {
        case GL_DEBUG_SEVERITY_HIGH:         /**/ return "High"sv;
        case GL_DEBUG_SEVERITY_MEDIUM:       /**/ return "Medium"sv;
        case GL_DEBUG_SEVERITY_LOW:          /**/ return "Low"sv;
        case GL_DEBUG_SEVERITY_NOTIFICATION: /**/ return "Notification"sv;
        default: return "???"sv;
        } }() 
    };
    std::string_view const str_message  /**/ { 
        std::string_view{ message, static_cast<size_t>(length) } 
    };
    std::string      const error        /**/ { std::format("|"
        "| GL Error : {:<8} |"
        "| Source   : {:<8} |"
        "| Type     : {:<8} |"
        "| Severity : {:<8} |"
        "| Message  : {:<8} |"
        "|\n",
        id,
        str_source,
        str_type,
        str_severity,
        str_message
    ) };
    /* Repeat handeling */ {
        size_t const hash_message = std::hash<std::string_view>{}(error);
        size_t static constinit hash_prev = 0, repeat = 0;
        if (hash_prev == hash_message) {
            std::cerr << "|| GL Error ^^^ x"<< repeat++ << '\r';
            return;
        }
        hash_prev = hash_message;
        repeat = 1;
    }
    std::cerr << error;
    // DebugBreak();
}
static bool wm_command(WORD cmd) {
    switch (cmd) {
    case IDM_ABOUT: {
        DialogBox(win_resources.hInstance, MAKEINTRESOURCE(IDD_ABOUTBOX), hwnd, About);
    } break;
    case IDM_DEBUG_CONSOLE: {
        (void)create_console();

        HWND console = GetConsoleWindow();
        BOOL shown = !IsWindowVisible(console);
        HMENU menu = GetMenu(hwnd);

        ShowWindow(console, shown ? SW_SHOW : SW_HIDE);
        CheckMenuItem(menu, IDM_DEBUG_CONSOLE, shown ? MF_CHECKED : MF_UNCHECKED);
        printf("%s console\n", shown ? "Show" : "Hide");
    } break;
    case IDM_DEBUG_RESET: {
        reset_game();
    } break;
    case IDM_DEBUG_REBUILDSHADERS: {
        game.build_shaders();
    } break;
    case IDM_DEBUG_REBUILDTEXTURES: {
        game.build_textures();
    } break;
    case IDM_EXIT: {
        DestroyWindow(hwnd);
    } break;
    default: return false;
    }
    return true;
}
void timer_proc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) {
    game.update();
    InvalidateRect(hwnd, nullptr, false);
}
static auto APIENTRY window_proc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam) noexcept -> LRESULT {
    switch (message) {
    case WM_CREATE: {
        HDC const hdc = GetDC(hwnd);

        setup_pixel_format(hdc);

        HGLRC const hglrc = wglCreateContext(hdc);
        wglMakeCurrent(hdc, hglrc);

        ReleaseDC(hwnd, hdc);

        gl::set_load_proc([](char const* name) {
            PROC proc = wglGetProcAddress(name);
            printf("Loaded at %p %s\n", proc, name);
            return reinterpret_cast<gl::proc_t>(proc);
        });

        puts("OpenGL context ready");

        gl::glEnable(GL_DEBUG_OUTPUT);
        gl::glDebugMessageCallback(opengl_debug, nullptr);

        game = { hwnd };
        reset_game();

        timer = SetTimer(hwnd, 0, UINT(1'000.0f / target_fps), timer_proc);
    } break;
    case WM_CLOSE: {
        game = {};
        wglMakeCurrent(nullptr, nullptr);
        wglDeleteContext(wglGetCurrentContext());
        DestroyWindow(hwnd);
    } break;
    case WM_DESTROY: {
        PostQuitMessage(0);
    } break;
    case WM_COMMAND: {
        if (!wm_command(LOWORD(wparam)))
            return DefWindowProc(hwnd, message, wparam, lparam);
    } break;
    case WM_ERASEBKGND: {
        return TRUE;
    } break;
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        game.draw();
        SwapBuffers(hdc);
        EndPaint(hwnd, &ps);
    } break;
    case WM_SIZE: {
        auto const w = LOWORD(lparam);
        auto const h = HIWORD(lparam);
        gl::glViewport(0, 0, w, h);
    } break;
    default:
        return DefWindowProc(hwnd, message, wparam, lparam);
    }
    return 0;
}

int APIENTRY wWinMain(_In_     HINSTANCE hInstance,
    [[maybe_unused ]] _In_opt_ HINSTANCE hPrevInstance,
    [[maybe_unused ]] _In_     LPWSTR    lpCmdLine,
    /*             */ _In_     int       nCmdShow) {

    (void)create_console();

    puts("Program Start!");

    win_resources = grab_resources(hInstance);

    register_class(hInstance, win_resources.window_class.c_str(), window_proc);
    auto hwnd_owned = make_hwnd(hInstance, win_resources.window_class.c_str(), win_resources.window_title.c_str());

    if (hwnd = hwnd_owned.get());
    else return EXIT_FAILURE;

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    auto const hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_GAMEOFLIFE));

    MSG msg{};
    while (GetMessage(&msg, nullptr, 0, 0))
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) {
            if (msg.message == WM_QUIT) 
                exit(0);
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    return static_cast<int>(msg.wParam);
}